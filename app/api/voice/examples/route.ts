/**
 * Voice Examples API - List and Create
 * GET /api/voice/examples - List all user's voice training examples
 * POST /api/voice/examples - Add a new voice training example
 */

import { NextRequest } from 'next/server';
import { withAuth } from '@/lib/api/with-auth';
import { responses, errors } from '@/lib/api/response';
import { validateBody, getPagination } from '@/lib/api/validate';
import { rateLimit } from '@/lib/api/rate-limit';
import { db } from '@/lib/db';
import { voiceExamples, pillars } from '@/lib/db/schema';
import { eq, and, sql } from 'drizzle-orm';
import { z } from 'zod';
import { canAddVoiceExample } from '@/lib/ai/usage';

// Validation schema â€“ aligned with frontend (minimum 50 characters)
const createVoiceExampleSchema = z.object({
  postText: z.string().min(50, 'Post must be at least 50 characters').max(3000, 'Post must be at most 3000 characters'),
  pillarId: z.string().uuid().optional(),
  source: z.enum(['own_post', 'reference']).optional().default('own_post'),
});

/**
 * GET /api/voice/examples
 * List all voice training examples for the user
 */
export const GET = withAuth(async (req: NextRequest, { user }) => {
  try {
    // Rate limiting
    const limited = await rateLimit(req, user.id, 'authenticated');
    if (limited) return limited;

    // Get query parameters
    const { searchParams } = new URL(req.url);
    const status = searchParams.get('status') || 'all';
    const pillarId = searchParams.get('pillarId');
    const { page, limit, offset } = getPagination(req);

    // Build where clause
    const whereConditions = [eq(voiceExamples.userId, user.id)];
    if (status !== 'all') {
      whereConditions.push(eq(voiceExamples.status, status));
    }
    if (pillarId) {
      whereConditions.push(eq(voiceExamples.pillarId, pillarId));
    }

    // Query examples with pillar info
    const examples = await db
      .select({
        id: voiceExamples.id,
        postText: voiceExamples.postText,
        characterCount: voiceExamples.characterCount,
        status: voiceExamples.status,
        source: voiceExamples.source,
        createdAt: voiceExamples.createdAt,
        pillarId: voiceExamples.pillarId,
        pillarName: pillars.name,
      })
      .from(voiceExamples)
      .leftJoin(pillars, eq(voiceExamples.pillarId, pillars.id))
      .where(and(...whereConditions))
      .orderBy(sql`${voiceExamples.createdAt} desc`)
      .limit(limit)
      .offset(offset);

    // Get total count
    const [{ count }] = await db
      .select({ count: sql<number>`count(*)::int` })
      .from(voiceExamples)
      .where(and(...whereConditions));

    return responses.list(examples, page, limit, count);
  } catch (error) {
    console.error('Error fetching voice examples:', error);
    return errors.internal('Failed to fetch voice examples');
  }
});

/**
 * POST /api/voice/examples
 * Add a new voice training example
 */
export const POST = withAuth(async (req: NextRequest, { user }) => {
  try {
    // Rate limiting
    const limited = await rateLimit(req, user.id, 'authenticated');
    if (limited) return limited;

    // Validate request body
    const result = await validateBody(req, createVoiceExampleSchema);
    if (!result.success) return result.error;

    const data = result.data;

    // Check voice example limit from subscription plan
    const voiceCheck = await canAddVoiceExample(user.id);
    if (!voiceCheck.allowed) {
      return errors.paymentRequired(voiceCheck.reason || 'Voice example limit reached. Upgrade your plan to add more.');
    }

    // If pillarId provided, verify it belongs to user
    if (data.pillarId) {
      const pillar = await db.query.pillars.findFirst({
        where: and(
          eq(pillars.id, data.pillarId),
          eq(pillars.userId, user.id)
        ),
      });

      if (!pillar) {
        return errors.badRequest('Invalid pillar ID');
      }
    }

    // Calculate character count
    const characterCount = data.postText.length;

    // Create voice example
    const [newExample] = await db
      .insert(voiceExamples)
      .values({
        userId: user.id,
        postText: data.postText,
        characterCount,
        pillarId: data.pillarId || null,
        status: 'active',
        source: data.source,
        // Note: embedding will be generated by background job
      })
      .returning();

    // TODO: Trigger background job to generate embedding
    // await queue.add('generate-voice-embedding', { exampleId: newExample.id });

    return responses.created(newExample);
  } catch (error) {
    console.error('Error creating voice example:', error);
    return errors.internal('Failed to create voice example');
  }
});
